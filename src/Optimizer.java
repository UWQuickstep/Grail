/*
Copyright (c) 2015,
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the University of Wisconsin-Madison nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JING FAN, ADALBERT GERALD SOOSAI RAJ, AND JIGNESH
M. PATEL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import Block.Block;
import Block.EndWhileBlock;
import Block.FlowControlBlock;
import Block.InsertUpdateBlock;
import Block.UpdateVertexBlock;

/**
 * @brief This class is the optimizer for Grail.
 */
public class Optimizer {
  // The configuration options, recording the direction of sending message, etc.
  private HashMap<String, String> options = null;
  // Generated SQL blocks.
  private ArrayList<Block> blocks = new ArrayList<Block>();
  // Senders of messages (tables that will be used to send messages).
  private HashSet<String> senders;

  /**
   * @brief Constructor.
   * @param options The options generated by parser.
   * @param blocks The blocks generated by translator.
   * @param senders Message senders.
   */
  public Optimizer(HashMap<String, String> options,
                   ArrayList<Block> blocks,
                   HashSet<String> senders) {
    this.options = options;
    this.blocks = blocks;
    this.senders = senders;
  }

  /**
   * @brief Create index on the edge table according to the direction of
   * sending messages.
   */
  private void createIdx() {
    String dir = this.options.get("SendMsgDir");
    int idx;
    for (idx = 0; idx < blocks.size(); ++idx) {
      if (blocks.get(idx).getStage().equals("beginWhile")) break;
    }
    switch (dir) {
      case "in":
        this.blocks.add(idx, new Block("createIdx",
                                       0,
                                       getCreateIdxSQL("dest")));
        break;
      case "out":
        this.blocks.add(idx, new Block("createIdx",
                                       0,
                                       getCreateIdxSQL("src")));
        break;
      case "all":
        this.blocks.add(idx, new Block("createIdx",
                                       0,
                                       getCreateIdxSQL("src")));
        this.blocks.add(idx, new Block("createIdx",
                                       0,
                                       getCreateIdxSQL("dest")));
        break;
    }
  }

  /**
   * @brief Generate the SQL for creating index.
   * @param attr The attribute to create index on.
   * @return The string of the SQL statement.
   */
  private String getCreateIdxSQL(String attr) {
    return "CREATE INDEX idx_" + attr + " ON edge(" + attr + ")";
  }

  /**
   * @brief Merge sending message and combining message to avoid the
   * materialization of table message. At the same time, we can change the
   * API of initialMessage to initialSender (Optionally).
   */
  public void mergeSendCombineMsg() {

    ArrayList<Block> dropBlocks = new ArrayList<Block>();

    // Remove drop senders block.
    for (String sender : senders) {
        for (int i = 0; i < this.blocks.size(); ++i) {
            if (blocks.get(i).getStage().equals("drop"+sender)) {
                if (!sender.equals("cur")) {
                    dropBlocks.add(this.blocks.remove(i));
                } else {
                    blocks.set(i,new Block("renamecur",
                                           this.blocks.get(i).getIndentLevel(),
                                           "EXEC SP_RENAME 'cur','cur_alias'"));
                    dropBlocks.add(new Block("dropcuralias",
                                             this.blocks.get(i).getIndentLevel(),
                                             "DROP TABLE cur_alias"));
                }
                break;
            }
        }
    }
    blocks.add(0, new Block("intdropcuralias", 0, "DROP TABLE cur_alias"));

    // Get the combineMsg block.
    int combineMsgBlockIndex = 0;
    for (combineMsgBlockIndex = 0;
       combineMsgBlockIndex < this.blocks.size();
       ++combineMsgBlockIndex) {
      if (this.blocks.get(combineMsgBlockIndex)
          .getStage().equals("combineMsg")) {
        break;
      }
    }

    // Get the sendMsg block.
    int sendMsgBlockIndex = 0;
    for (sendMsgBlockIndex = 0;
       sendMsgBlockIndex < this.blocks.size();
       ++sendMsgBlockIndex) {
      if (this.blocks.get(sendMsgBlockIndex)
          .getStage().equals("sendMsg")) break;
    }
    // combineMsgBlockIndex and sendMsgBlockIndex indicate the position of
    // combine message block and send message block.
    String combineMsg = this.blocks.get(combineMsgBlockIndex).getSql();
    String sendMsg = this.blocks.get(sendMsgBlockIndex).getSql();
    Block sendMsgBlock = this.blocks.get(sendMsgBlockIndex);
    int indent = this.blocks.get(combineMsgBlockIndex).getIndentLevel();
    this.blocks.remove(combineMsgBlockIndex);
    this.blocks.remove(sendMsgBlockIndex-1);
    String aggFunc = this.options.get("aggFunc")
                         .replace("message.val",
                                  this.options.get("contentStr"));
    if (this.options.get("msgDir").equals("all")) {
      sendMsgBlock.append("GROUP BY id");
      sendMsg = sendMsgBlock.getSql();
      sendMsg = sendMsg.replace("SELECT *", "SELECT id, "
            + this.options.get("aggFunc").replace("message.val", "val")
            + " as val ");
      sendMsg = sendMsg.replace("GROUP BY src", "");
      sendMsg = sendMsg.replace("GROUP BY dest", "");
    } else {
      sendMsg = sendMsg.replace(this.options.get("contentStr"), aggFunc);
    }
    sendMsg = sendMsg.replace("cur", "cur_alias");
    sendMsg = sendMsg.replace("INTO message", "INTO cur");
    // Merge these two parts.
    Block setIsFirstBlock = new Block("setIsFirst", indent, "SET @isFirst = 0");

    for (Block block : dropBlocks) {
        sendMsg += block.getSql();
    }

    // Add flow control. Because when we start the program, we will use the
    // initial messages defined, but later we will use table joins to generate
    // messages.
    this.blocks.add(combineMsgBlockIndex,
                    new FlowControlBlock("flowControl",
                                         indent,
                                         "@isFirst = 1",
                                         combineMsg + setIsFirstBlock.getSql(),
                                         sendMsg));
    // Remove drop message block.
    int i;
    for (i = 0; i < this.blocks.size(); ++i) {
      if (this.blocks.get(i).getStage().equals("dropmessage")) break;
    }
    this.blocks.remove(i);
    for (i = 0; i < this.blocks.size(); ++i) {
      if (this.blocks.get(i).getStage().equals("beginWhile")) break;
    }
    Block declareFCBlock = new Block("declareFC",
                                     this.blocks.get(i).getIndentLevel());
    declareFCBlock.append("DECLARE @isFirst int");
    declareFCBlock.append("SET @isFirst = 1");
    this.blocks.add(i, declareFCBlock);
    for (i = 0; i < this.blocks.size(); ++i) {
      if (this.blocks.get(i).getStage().equals("endWhile")) break;
    }
    EndWhileBlock endWhileBlock = (EndWhileBlock) this.blocks.get(i);
    this.blocks.set(i, new EndWhileBlock(endWhileBlock.getStage(),
                                         endWhileBlock.getIndentLevel(),
                                         endWhileBlock.getEndStr(),
                                         this.senders.iterator().next()));
  }

  /**
   * @brief Reduce update when all vertices are senders.
   */
  public void allSender() {
    if (this.options.get("isSender").equals("all")
     && this.options.get("setValNewVal").equals("cur.val")) {
      int idx;
      UpdateVertexBlock block = null;
      for (idx = 0; idx < this.blocks.size(); ++idx) {
        if (this.blocks.get(idx).getStage().equals("setVal")) {
          block = (UpdateVertexBlock) this.blocks.get(idx);
          break;
        }
      }
      this.blocks.remove(idx);
      this.blocks.add(idx, new InsertUpdateBlock(block));
    }
  }

  /**
   * @brief Run optimization.
   */
  public void run() {
    this.createIdx();
    this.mergeSendCombineMsg();
    this.allSender();
  }
}
